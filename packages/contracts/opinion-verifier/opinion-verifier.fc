#include "stdlib.fc";
#include "op-codes.fc";

int min_tons_for_storage() asm "50000000 PUSHINT"; ;; 0.05 TON

(int, slice) load_data() inline {                 ;; read function declaration - returns int as result
  var ds = get_data().begin_parse();       ;; load the storage cell and start parsing as a slice
  return (ds~load_uint(256), ds~load_msg_addr());              ;; read a 256 bit unsigned int from the slice and return it
}

() save_data(int hash, slice owner) impure inline {     ;; write function declaration - takes an int as arg
  set_data(begin_cell()                    ;; store the storage cell and create it with a builder 
    .store_uint(hash, 256)                 ;; write a 256 bit unsigned int to the builder
    .store_slice(owner)                    ;; write the owner address
    .end_cell());                          ;; convert the builder to a cell
}

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {  ;; well known function signature
  ~dump(msg_value);
  ~strdump(in_msg_body);
  if (in_msg_body.slice_empty?()) {         ;; check if incoming message is empty (with no body)
    return ();                              ;; return successfully and accept an empty message
  }
  int op = in_msg_body~load_uint(32);       ;; parse the operation type encoded in the beginning of msg body
  _ = in_msg_body~load_uint(64);            ;; discard query id
  slice opinion_string = in_msg_body;
  var (old_hash, owner) = load_data();      ;; call our read utility function to load values from storage

  if (op == op::receive_opinion_string()) { ;; handle op "receive_opinion_string"c
    ~strdump(opinion_string);
    int opinion_hash = string_hash(opinion_string);
    ~dump(opinion_hash);
    int hash_xor = opinion_hash ^ old_hash;
    ~dump(hash_xor);
    save_data(hash_xor, owner);             ;; call our write utility function to persist values to storage
  }

  if (op == op::pay_balance_back()) {       ;; handle op "pay_balance_back"c
    ~strdump("return ton balance of smart contract to owner"); 
    [int my_balance, _] = get_balance();
    ~dump(my_balance);
    my_balance -= min_tons_for_storage();
    ~dump(my_balance);
    throw_unless(80, my_balance >= 0);      ;; insufficent founds
    slice message_body = "Fund back from counter";
    cell msg = begin_cell()
      .store_uint(0x18, 6)
      .store_slice(owner)
      .store_coins(my_balance)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_slice(message_body)
    .end_cell();
    send_raw_message(msg, 2);
  }
}

(int, slice) get_info() method_id {         ;; getter declaration - returns int, slice as result
  return load_data();                       ;; call our read utility function to load value
}
